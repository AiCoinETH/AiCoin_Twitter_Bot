# -*- coding: utf-8 -*-
"""
–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ (RU) –¥–ª—è –∫–∞–Ω–∞–ª–∞ —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—è:
- Google Trends: —Ç–æ–ø-3 —Å—Ç—Ä–∞–Ω—ã –ø–æ –∫–ª—é—á–∞–º (now 7-d)
- –î–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–∞–Ω—ã: —Ç–æ–ø-3 related queries, –¥–æ–º–µ–Ω—ã (–∏–∑ queries –∏ —Ç–≤–∏—Ç–æ–≤), —Ç–æ–ø —Ö—ç—à—Ç–µ–≥–∏ X
- –ö–Ω–æ–ø–∫–∏ "üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å ‚Äî <—Å—Ç—Ä–∞–Ω–∞>" -> deeplink –≤ –õ–° –±–æ—Ç–∞ /start copy_<ISO2>

–ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: pytrends, snscrape, python-telegram-bot==21.*, pycountry
"""

import os, re, textwrap, ssl, warnings, asyncio
from collections import Counter
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

# --- SSL workaround –¥–ª—è GitHub Actions / snscrape (–Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ, –Ω–æ –Ω—É–∂–Ω–æ –¥–ª—è —Ç–µ—Å—Ç–æ–≤) ---
try:
    ssl._create_default_https_context = ssl._create_unverified_context  # noqa: SLF001
except Exception:
    pass
warnings.filterwarnings("ignore", message=".*certificate verify failed.*", category=UserWarning)
warnings.filterwarnings("ignore", category=RuntimeWarning)

from telegram import Bot, InlineKeyboardButton, InlineKeyboardMarkup
from pytrends.request import TrendReq
import pycountry

try:
    import snscrape.modules.twitter as sntwitter
    SNS_OK = True
except Exception:
    SNS_OK = False

# ------------------ ENV (—Ç–µ—Å—Ç–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è ‚Äî –ø–æ —Ç–≤–æ–µ–π –ø—Ä–æ—Å—å–±–µ) ------------------
TOKEN        = "8326777624:AAG_Owp9T4zsFryttparUnqjqtrVhpHR_LQ"
CHAT_ID      = "-1002892475684"    # –∫–∞–Ω–∞–ª —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–∏—è
BOT_USERNAME = "AiCoinBot"         # –±–µ–∑ @, –¥–ª—è deeplink
APPROVAL_USER_ID = "6105016521"    # —Ç–≤–æ–π Telegram ID (–Ω–∞ –±—É–¥—É—â–µ–µ)

# ------------------ –ù–ê–°–¢–†–û–ô–ö–ò ------------------
SEARCH_TERMS = ["Ai Coin", "AI crypto", "blockchain AI", "$Ai"]
KYIV_TZ = ZoneInfo("Europe/Kyiv")
MAX_COUNTRIES = 3
TOP_N_QUERIES = 3
TW_SAMPLE = 180  # —Å–∫–æ–ª—å–∫–æ —Ç–≤–∏—Ç–æ–≤ —Å—ç–º–ø–ª–∏—Ä–æ–≤–∞—Ç—å –º–∞–∫—Å–∏–º—É–º

DOMAIN_RE = re.compile(r"(?:https?://)?([a-z0-9\-]+\.[a-z\.]{2,})(?:/|$)", re.I)

def _extract_domains(text: str) -> list[str]:
    return [m.group(1).lower() for m in DOMAIN_RE.finditer(text or "")]

def _iso2_from_name(name: str) -> str | None:
    try:
        if name == "United States": name = "United States of America"
        return pycountry.countries.lookup(name).alpha_2
    except Exception:
        return None

def _flag(iso2: str) -> str:
    if not iso2 or len(iso2)!=2: return "üåç"
    base = 0x1F1E6
    return "".join(chr(base + ord(c.upper()) - ord('A')) for c in iso2)

def _local_time_label(iso2: str) -> tuple[str, str]:
    tzmap = {
        "UA":"Europe/Kyiv","DE":"Europe/Berlin","TR":"Europe/Istanbul","GB":"Europe/London",
        "US":"America/New_York","CA":"America/Toronto","BR":"America/Sao_Paulo","MX":"America/Mexico_City",
        "IN":"Asia/Kolkata","ID":"Asia/Jakarta","PH":"Asia/Manila","JP":"Asia/Tokyo",
        "AE":"Asia/Dubai","SA":"Asia/Riyadh","NG":"Africa/Lagos","ZA":"Africa/Johannesburg"
    }
    tz = ZoneInfo(tzmap.get(iso2, "UTC"))
    now_local = datetime.now(tz).strftime("%Y-%m-%d %H:%M")
    return now_local, tz.key

# ---------------- –ë–µ–∑–æ–ø–∞—Å–Ω—ã–µ –≤—ã–∑–æ–≤—ã ----------------
def _safe(callable_, default):
    try:
        return callable_()
    except Exception:
        return default

# ---------------- Google Trends ----------------
def trends_top_countries() -> list[tuple[str, str, int]]:
    def _inner():
        py = TrendReq(hl='en-US', tz=0)
        py.build_payload(SEARCH_TERMS, timeframe='now 7-d', geo='')
        df = py.interest_by_region(resolution='COUNTRY', inc_low_vol=True)
        if df.empty:
            return []
        df['score'] = df.sum(axis=1)
        df = df[df['score'] > 0].sort_values('score', ascending=False)
        out = []
        for name, score in df['score'].head(10).items():
            iso2 = _iso2_from_name(name)
            if iso2:
                out.append((name, iso2, int(score)))
            if len(out) >= 6:
                break
        return out
    return _safe(_inner, [])

def related_queries_top(iso2: str, top_n: int = TOP_N_QUERIES) -> tuple[list[str], list[str]]:
    def _inner():
        py = TrendReq(hl='en-US', tz=0)
        py.build_payload(SEARCH_TERMS, timeframe='now 7-d', geo=iso2)
        rq = py.related_queries()
        q_counter = Counter()
        d_counter = Counter()
        for _, data in (rq or {}).items():
            if not data: continue
            for kind in ("rising", "top"):
                df = data.get(kind)
                if df is None: continue
                for _, row in df.head(12).iterrows():
                    q = str(row.get('query') or '').strip()
                    if not q: continue
                    q_counter[q] += int(row.get('value') or 0)
                    for d in _extract_domains(q):
                        d_counter[d] += 1
        top_queries = [q for q,_ in q_counter.most_common(top_n)]
        top_domains = [d for d,_ in d_counter.most_common(5)]
        return top_queries, top_domains
    return _safe(_inner, ([], []))

# ---------------- Twitter (snscrape) ----------------
def twitter_domains_and_tags(country_label: str, limit=TW_SAMPLE) -> tuple[list[str], list[str]]:
    if not SNS_OK:
        return [], []
    def _inner():
        query = f'("Ai Coin" OR "AI crypto" OR "blockchain AI" OR "$Ai") {country_label} since:{(datetime.utcnow()-timedelta(days=1)).date()}'
        domains = Counter()
        tags = Counter()
        for i, tw in enumerate(sntwitter.TwitterSearchScraper(query).get_items()):
            if i >= limit: break
            for d in _extract_domains(getattr(tw, "content", "")):
                domains[d] += 1
            for tag in (getattr(tw, "hashtags", []) or []):
                t = str(tag).lower().lstrip("#")
                if t: tags[t] += 1
        return [d for d,_ in domains.most_common(6)], [f"#{t}" for t,_ in tags.most_common(6)]
    return _safe(_inner, ([], []))

# ---------------- –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∏ –∫–Ω–æ–ø–æ–∫ ----------------
def build_message_and_buttons():
    now_kyiv = datetime.now(KYIV_TZ).strftime("%Y-%m-%d %H:%M")
    countries = trends_top_countries()

    # –≤–æ–∑—å–º—ë–º –ø–µ—Ä–≤—ã–µ 3 —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –ø–æ ISO2
    picked, seen = [], set()
    for name, iso2, score in countries:
        if iso2 in seen: continue
        picked.append((name, iso2, score))
        seen.add(iso2)
        if len(picked) >= MAX_COUNTRIES: break

    lines = [
        f"üìä <b>–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ —Ç—Ä–µ–Ω–¥–æ–≤</b>",
        f"üïí –í—Ä–µ–º—è –∞–Ω–∞–ª–∏–∑–∞: {now_kyiv} (–ö–∏–µ–≤)",
        f"üîé –ò—Å—Ç–æ—á–Ω–∏–∫–∏: Google Trends + Twitter (snscrape)",
        f"üí° –¢–µ–º–∞: {', '.join(SEARCH_TERMS)}",
        ""
    ]
    buttons = []

    if not picked:
        lines.append("–î–∞–Ω–Ω—ã—Ö –ø–æ —Å—Ç—Ä–∞–Ω–∞–º –Ω–µ—Ç —Å–µ–≥–æ–¥–Ω—è.")
    else:
        for idx, (country, iso2, score) in enumerate(picked, 1):
            flag = _flag(iso2)
            local_now, tzkey = _local_time_label(iso2)

            top_queries, rq_domains = related_queries_top(iso2)
            tw_domains, tw_tags = twitter_domains_and_tags(country)

            # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–æ–º–µ–Ω—ã (–∏–∑ Trends –∏ Twitter), —É–±–∏—Ä–∞–µ–º –ø–æ–≤—Ç–æ—Ä—ã
            seen_d, domains = set(), []
            for d in (rq_domains + tw_domains):
                if d in seen_d: continue
                seen_d.add(d); domains.append(d)
            if not domains:
                domains = ["getaicoin.com"]

            block = textwrap.dedent(f"""\
                {idx}Ô∏è‚É£ {flag} <b>{country}</b>
                üïí –õ–æ–∫–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è —Å–µ–π—á–∞—Å: {local_now} [{tzkey}]
                üìà –¢–æ–ø‚Äë3 —Ç–µ–º—ã (Google): {(' ¬∑ '.join(top_queries) if top_queries else '‚Äî')}
                üåê –ß–∞—Å—Ç–æ –≤—Å—Ç—Ä–µ—á–∞—é—â–∏–µ—Å—è —Å–∞–π—Ç—ã: {', '.join(domains[:3])}
                üè∑Ô∏è –•—ç—à—Ç–µ–≥–∏ X: {(' '.join(tw_tags[:3]) if tw_tags else '#AiCoin #AI #crypto')}
            """).rstrip()
            lines.append(block)

            if BOT_USERNAME:
                deeplink = f"https://t.me/{BOT_USERNAME}?start=copy_{iso2}"
                buttons.append([InlineKeyboardButton(f"üìã –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å ‚Äî {country}", url=deeplink)])

    text = "\n\n".join(lines)
    kb = InlineKeyboardMarkup(buttons) if buttons else None
    return text, kb

# ---------------- –û—Ç–ø—Ä–∞–≤–∫–∞ (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è) ----------------
async def _send_long(bot: Bot, chat_id: str, text: str, **kw):
    LIMIT = 3900  # –∑–∞–ø–∞—Å –ø–æ–¥ HTML-—Ç–µ–≥–∏
    if len(text) <= LIMIT:
        await bot.send_message(chat_id=chat_id, text=text, **kw)
        return
    parts = []
    cur = ""
    for line in text.splitlines(True):
        if len(cur) + len(line) > LIMIT:
            parts.append(cur)
            cur = line
        else:
            cur += line
    if cur: parts.append(cur)
    for i, p in enumerate(parts):
        await bot.send_message(chat_id=chat_id, text=p, **kw if i == 0 else {k:v for k,v in kw.items() if k != "reply_markup"})

async def amain():
    bot = Bot(token=TOKEN)
    text, kb = build_message_and_buttons()
    await _send_long(
        bot,
        CHAT_ID,
        text,
        parse_mode="HTML",
        disable_web_page_preview=True,
        reply_markup=kb
    )

if __name__ == "__main__":
    asyncio.run(amain())